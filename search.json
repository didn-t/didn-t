[{"title":"日月双塔","url":"/2025/06/07/日月双塔/","content":"\n## 天刚暗下来，日月双塔开灯了\n![](\\img\\DSC3745.jpg)\n\n暮色漫过桂林的天空，日月双塔在光影里静静相依。红叶轻框，似是时光精心雕琢的画境。冷暖灯光亮起，勾勒双塔风姿，与天边淡蓝交织成诗。水波微漾，映着这双塔风华，喧嚣远去，唯留宁静在心底悄然生长。\n\n![](\\img\\DSC3749.jpg)\n\n","tags":["桂林"],"categories":["alban"]},{"title":"Debian安装Docker","url":"/2025/06/07/debian安装docker/","content":"\n### ** Debian 系统安装Docker**\n\n#### **1. 卸载旧版本（如有）**\n\n```bash\nsudo apt-get remove docker docker-engine docker.io containerd runc\n```\n\n#### **2. 安装依赖工具**\n\n```bash\nsudo apt-get update\nsudo apt-get install -y ca-certificates curl gnupg lsb-release\n```\n\n#### **3. 添加 Docker 官方 GPG 密钥**\n\n```bash\nsudo mkdir -p /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n```\n\n#### **4. 设置 Docker 官方软件源**\n\n```bash\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n```\n\n#### **5. 更新软件包索引并安装 Docker**\n\n```bash\nsudo apt-get update\nsudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\n```\n\n#### **6. 启动 Docker 并设置开机自启**\n\n```bash\nsudo systemctl enable docker\nsudo systemctl start docker\n```\n\n#### **7. 验证安装**\n\n```bash\nsudo docker run hello-world\n```\n\n\n\n","tags":["配置环境"],"categories":["code"]},{"title":"Djanngo项目部署到服务器","url":"/2025/06/07/django部署/","content":"\n## Djanngo项目部署到服务器\n\n### virtualenv虚拟机\n\n安装命令\n\n```bash\nsudo apt install python3-virtualenv\n```\n\n创建虚拟机\n\n```\nvirtualenv env\n```\n\n**注**：env是虚拟机名\n\n启动虚拟机\n\n```shell\nsource env/bin/activate\n```\n\n安装需要python包，如Django\n\n```shell\npip install django\n```\n\n### 运行python项目\n\n使用git把包传进服务器\n\n进入项目目录启动django\n\n```shell\npython manage.py runserver\n```\n\n或\n\n```shell\npython manage.py runserver 0.0.0.0:8000\n```\n\n把静态文件放到指定目录\n\n如 /home/static \n\n**注**：不建议放root目录下，可能没权限访问\n\n项目setting.py里设置\n\n```django\nSTATIC_URL = '/static/'\n\nSTATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'),]\nSTATIC_ROOT = '/home/static/'\n```\n\n然后收集静态资源文件\n\n```shell\npython manage.py collectstatic\n```\n\n### 安装和配置nginx\n\n安装命令\n\n```shell\nsudo apt install nginx\n```\n\nnginx目录/etc/nginx\n\n```shell\ncd /etc/nginx\n```\n\n进入sites-enabled目录\n\n```shell\ncd /etc/nginx/sites-enabled\n```\n\n里面的default文件\n\n```nginx\n##\n# You should look at the following URL's in order to grasp a solid understanding\n# of Nginx configuration files in order to fully unleash the power of Nginx.\n# https://www.nginx.com/resources/wiki/start/\n# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/\n# https://wiki.debian.org/Nginx/DirectoryStructure\n#\n# In most cases, administrators will remove this file from sites-enabled/ and\n# leave it as reference inside of sites-available where it will continue to be\n# updated by the nginx packaging team.\n#\n# This file will automatically load configuration files provided by other\n# applications, such as Drupal or Wordpress. These applications will be made\n# available underneath a path with that package name, such as /drupal8.\n#\n# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.\n##\n\n# Default server configuration\n#\nserver {\n        listen 80 default_server;\n        listen [::]:80 default_server;\n\n        # SSL configuration\n        #\n        # listen 443 ssl default_server;\n        # listen [::]:443 ssl default_server;\n        #\n        # Note: You should disable gzip for SSL traffic.\n        # See: https://bugs.debian.org/773332\n        #\n        # Read up on ssl_ciphers to ensure a secure configuration.\n        # See: https://bugs.debian.org/765782\n        #\n        # Self signed certs generated by the ssl-cert package\n        # Don't use them in a production server!\n        #\n        # include snippets/snakeoil.conf;\n\n        root /var/www/html;\n\n        # Add index.php to the list if you are using PHP\n        index index.html index.htm index.nginx-debian.html;\n\n        server_name _;\n\n        location / {\n                # First attempt to serve request as file, then\n\n```\n\n不管它，直接删除\n\n```shell\nrm default\n```\n\n新建一个配置文件\n\n```shell\nvim cf.conf\n```\n\n添加到文件里\n```nginx\nserver {\n    server_name www.com; #这里改为你的域名\n\n    # 新添加的静态文件处理块\n    location /static/ {\n        alias /home/static/;  # 替换为您的STATIC_ROOT路径\n        expires 30d;\n        access_log on;\n        add_header Cache-Control \"public\";\n    }\n\n    location / {\n        include proxy_params;\n        proxy_pass http://127.0.0.1:8000;\n    }\n\n}\n\n```\n\n保存好文件\n\n```shell\nsudo nginx -t\n#检查nginx配置语法，成功有successful字样\n```\n\n重载nginx\n\n```shell\nsudo systemctl reload nginx\n#或者\nsudo nginx -s reload\n\n\nsudo systemctl start nginx # 启动nginx\nsudo systemctl stop nginx # 关闭nginx\n```\n\n开启80和443端口\n\n```shell\nsudo ufw allow 80/tcp\nsudo ufw allow 443/tcp\n\n#查看防火墙状态\nsudo ufw status\n```\n\n\n\n## 安装SSL证书并启用HTTPS\n\n### 1. 安装Certbot和Nginx插件\n\n```\nsudo apt install certbot python3-certbot-nginx\n```\n\n### 2. 获取SSL证书\n\n```\nsudo certbot --nginx -d yourdomain.com -d www.yourdomain.com\n```\n\n(将yourdomain.com替换为你的实际域名)\n\n### 3. 自动续期测试\n\n```\nsudo certbot renew --dry-run\n```\n\n### 4. 修改Nginx配置自动重定向HTTP到HTTPS\n\n在之前的nginx配置中添加：\n\n```\nserver {\n    listen 80;\n    server_name yourdomain.com www.yourdomain.com;\n    return 301 https://$host$request_uri;\n}\n```\n\n### 5. 重启Nginx使配置生效\n\n```\nsudo systemctl restart nginx\n```\n\n这样就完成了HTTPS的配置，Certbot会自动处理证书续期问题。\n\n注意：在执行这些命令前，请确保：\n\n1. 域名已解析到服务器IP\n2. 80和443端口已开放\n3. Nginx配置中的server_name与域名一致\n","tags":["开发"],"categories":["code"]},{"title":"http协议","url":"/2025/06/07/http/","content":"\n## http协议\n1. 一个完整的HTTP URL（统一资源定位符）由多个部分组成，每个部分都有其特定的用途和语法规则。以下是HTTP URL的组成部分，以及哪些部分是可选的：\n   \n   1. **协议（Scheme）**：\n      - 格式：`http://` 或 `https://`\n      - 这是必需的部分，用于指定使用的协议。\n      - 例子：`http://` 或 `https://`\n   2. **用户名和密码（Userinfo）**：\n      - 格式：`username:password@`\n      - 这是可选的部分，通常用于需要认证的URL。\n      - 例子：`username:password@`\n      - 注意：在现代Web中，不建议在URL中包含用户名和密码，出于安全考虑。\n   3. **主机名（Hostname）**：\n      - 格式：`www.example.com`\n      - 这是必需的部分，用于指定服务器的域名或IP地址。\n      - 例子：`www.example.com` 或 `192.168.1.1`\n   4. **端口号（Port）**：\n      - 格式：`:8080`\n      - 这是可选的部分，用于指定服务器上的特定端口。\n      - 如果使用HTTP默认端口80或HTTPS默认端口443，可以省略。\n      - 例子：`:8080` 或 `:443`\n   5. **路径（Path）**：\n      - 格式：`/search`\n      - 这是必需的部分，用于指定服务器上的具体资源或页面。\n      - 例子：`/search` 或 `/images/photo.jpg`\n      - 如果路径是根目录，可以省略为`/`。\n   6. **查询字符串（Query String）**：\n      - 格式：`?q=HTTP&lang=zh`\n      - 这是可选的部分，用于传递参数和数据给服务器。\n      - 以问号 `?` 开始，包含键值对参数。\n      - 例子：`?q=HTTP&lang=zh`\n   7. **片段标识符（Fragment Identifier）**：\n      - 格式：`#section2`\n      - 这是可选的部分，用于指定页面内的某个部分或位置。\n      - 以井号 `#` 开始。\n      - 例子：`#section2`\n   \n   下面是一个完整的URL示例，包含所有这些元素：\n   ```\n   https://username:password@www.example.com:8080/search?q=HTTP&lang=zh#section2\n   ```\n   \n   解释：\n   - `https://` 是协议部分。\n   - `username:password@` 是用户名和密码，可选。\n   - `www.example.com` 是主机名。\n   - `:8080` 是端口号，可选。\n   - `/search` 是路径。\n   - `?q=HTTP&lang=zh` 是查询字符串，可选。\n   - `#section2` 是片段标识符，可选。\n   \n   总结：\n   - 必需的部分：协议、主机名、路径（至少为`/`）。\n   - 可选的部分：用户名和密码、端口号、查询字符串、片段标识符。\n\n","tags":["计算机网络"],"categories":["code"]},{"title":"栈——顺序栈","url":"/2024/11/30/stack/","content":"\n### 栈的定义\n堆栈又名栈（stack），它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈，弹栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n![](\\img\\stack.png)\n\n栈的特性就是先进后出\n\n### 栈的存储结构\n\n栈的存储结构分为两种：分别为顺序存储和链式存储，对应的名称即为顺序栈和链栈\n\n1. 顺序栈\n\n   采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的元素，同时附设一个指针（top）指示当前栈顶的位置。\n\n2. 链式栈\n\n   采用链式存储的栈称为链栈，链栈便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并且所有操作都是在单链表的表头进行的。\n\n### 本文只简单地构建一个顺序栈\n\n```c++\n#include<iostream>\n\nusing namespace std;\nconst int SIZE = 200; // 栈的大小\nstruct Stack {\n    int data[SIZE]; //数据类型对应的可以换成long,char,string...\n    int top;\n} stack;\n\nvoid initStack() { // 初始化栈\n    stack.top = -1; // top指向-1为空栈\n}\n\nint top() {\n    return stack.data[stack.top];\n}\n\nbool push(int v) {\n    if (stack.top == SIZE) return false; // 判断栈满\n    stack.top++;\n    stack.data[stack.top] = v;\n\n    // stack.data[++stack.top];//或者写成这个\n    return true;\n}\n\nvoid pop() {\n    if (stack.top == -1) return;\n    stack.top--;\n}\n\n\nint main() {\n    initStack(); //初始化\n    // 入栈1，2，3\n    push(1);\n    push(2);\n    push(3);\n\n    for (int i = 1; i <= 3; ++i) {\n        cout << top() << endl;\n        pop();\n    }\n    return 0;\n}\n```\n\n[合法括号](https://ac.nowcoder.com/acm/problem/200434) 这道题可以用栈来解决，可以动手尝试一下\n\n题解：一个 '( '对应一个 ')' 。 用一个字符串变量s存储给出的字符串，但s[i]为 '(' 时进栈 当 ')' 时把栈里的 '(' 出栈，构成一对()。当s[i]为 ')' 栈里没有 '(' 时则可以判断为NO，当s都遍历完后如果栈为空则输出YES，否则输出NO\n\n```c++\n#include<iostream>\n\nusing namespace std;\nconst int SIZE = 2000; //栈空间改大\nstruct Stack {\n    char data[SIZE]; //数据类型对应的可以换成long,char,string...\n    int top;\n} stack;\n\nvoid initStack() { // 初始化栈\n    stack.top = -1; // top指向-1为空栈\n}\n\nchar top() {\n    return stack.data[stack.top];\n}\n\n// 因为()是char类型的，这里也不要忘\nbool push(char v) {\n    if (stack.top == SIZE) return false; // 判断栈满\n    stack.top++;\n    stack.data[stack.top] = v;\n\n    // stack.data[++stack.top];//或者写成这个\n    return true;\n}\n\nbool pop() {\n    if (stack.top == -1) return false;\n    stack.top--;\n    return true;\n}\n\n\nint main() {\n    initStack(); //初始化\n    int n;\n    string s;\n    cin >> n >> s;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') {\n            push('(');\n        } else {\n            // s[i]为')'时\n            if (!pop()) { // 判断栈是否为空，为空输出NO并结束程序\n                cout << \"NO\";\n                return 0;\n            }\n        }\n    }\n    if (pop()) { // 栈不为空\n        cout << \"NO\";\n    } else {\n        cout << \"YES\";\n    }\n\n    return 0;\n}\n```\n\n当我们理解后我们并不需要我们自己来构建栈，可以直接使用c++STL库中的stack\n\n```c++\n#include<iostream>\n#include <stack> // 导入stack库\n\nusing namespace std;\n\nstack<int> s; // 创建一个int类型，变量名为s的栈\n\nint main() {\n    // stack常用的函数\n    s.push(1); // 入栈\n    s.pop(); // 出栈，删除栈顶元素，无返回值\n    s.empty(); // 判断栈空， 如果为空返回true，否则返回false\n    s.top(); // 栈顶元素\n    s.size(); // 栈的大小\n    return 0;\n}\n```","tags":["数据结构"],"categories":["code"]}]